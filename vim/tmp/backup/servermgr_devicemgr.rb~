#!/usr/bin/ruby
# servermgr_devicemgr.rb - serves as an interface between the rails app an servermgr_devicemgr
# This file is run by script/runner
# It expects an XML plist to come in on standard input. After the plist has been delivered, the sender
# should close it's standard output to send EOF.
#
# The XML plist should be a dictionary with the following keys:
# command - the command to execute
# (optional) payload - the data specific to the command
#

require 'plist'

ServerPreferencesGroupName='workgroup'

Rails.logger.debug "Running servermgr_devicemgr.rb"

class ServermgrDevicemgr
    
    @@knobSetModels = [ApnKnobSet, CalDavKnobSet, CalSubKnobSet, CardDavKnobSet, CertificateKnobSet, DirectoryKnobSet, EmailKnobSet, ExchangeKnobSet, GeneralKnobSet, IchatKnobSet,
                       LdapKnobSet, McxKnobSet, InterfaceKnobSet, PasscodeKnobSet, RestrictionsKnobSet, ScepKnobSet, SecurityKnobSet, VpnKnobSet, WebClipKnobSet, WifiKnobSet]

    def self.run
	input = $stdin.read
	Rails.logger.info("input: #{input}")
        inputPlist = Plist::parse_xml(input)
        command = inputPlist['command'].to_sym
        payload = inputPlist['payload']

        sd = ServermgrDevicemgr.new

        result = {}
        if payload != nil
            result = sd.send(command, payload)
        else
            payload = inputPlist
            payload.delete('command')
            if payload != {}
                result = sd.send(command, payload)
            else
                result = sd.send(command)
            end
        end

        $stdout.write(result.to_plist)
    end
    
    def clean_nils(structure)
        if structure.class == Hash
            new_hash = {}
            structure.each do |key, value|
                new_hash[key] = clean_nils(value)
            end
	    if new_hash == {}
		return ""
	    else
            	return new_hash
	    end
        elsif structure.class == Array
            new_array = []
            structure.each do |entry|
                new_array.push(clean_nils(entry))
            end
	    if new_array == []
		return ""
	    else
            	return new_array
	    end
        elsif structure == nil
            return ""
        else
            return structure
        end
    end
    
    def readSettings
        systemPrefsProfile = self.getSystemPrefsProfile
        cur_settings = Settings.get_settings.get_attributes
        if systemPrefsProfile.nil?
            return clean_nils({ :settings => {}, :configuration => cur_settings })
        else
            profile = ProfileManager.generate_profile(systemPrefsProfile)
            return_val = clean_nils({ :settings => profile, :configuration => cur_settings })
            return return_val
        end
    end
    
    def writeSettings(settings)
        profile_info = self.getSystemPrefsProfileInformation
        systemPrefsProfile = profile_info[:profile]
        serverPrefsGroupGUID = profile_info[:guid]
        fullName = profile_info[:name]
        
        if systemPrefsProfile.nil?
            user_group = UserGroup.find_by_guid(serverPrefsGroupGUID)

            if user_group == nil
                user_group = OpenDirectory::create_user_group_model_for_guid(serverPrefsGroupGUID)
                if user_group.nil?
                  raise "Couldn't create user group for #{serverPrefsGroupGUID}"
                  return nil
                end
            end
            
            systemPrefsProfile = Profile.new
            systemPrefsProfile.name = fullName
            systemPrefsProfile.is_from_servermgr = true
            systemPrefsProfile.save
            systemPrefsProfile.members.push(user_group)
            systemPrefsProfile.save
        end
        
        knob_set_array = systemPrefsProfile.knob_sets
        knob_set_array.each do |knob_set|
            knob_set.delete
        end
        systemPrefsProfile.knob_sets.clear
        systemPrefsProfile.save
        
        if settings.class == Hash
            settings = settings['settings']
        end

        settings.each do |settingsItem| 
            type = settingsItem['PayloadType']
            
            Rails.logger.debug "Configuring settings for #{type}"
            
            model = @@knobSetModels.find { |knobSetModel| knobSetModel.payload_type == type }
            if model.nil?
              raise "Could not find model for payload type #{type}"
              return nil
            end
            
            knob_set = model.new

            settingsItem['payload'].each do |key, value|
              if knob_set.respond_to?(key)
                knob_set[key] = value
              end
            end
           
            knob_set.save
            
            systemPrefsProfile.knob_sets.push(knob_set)
        end
       
        systemPrefsProfile.save

        if systemPrefsProfile.knob_sets == nil || systemPrefsProfile.knob_sets == []
            systemPrefsProfile.delete
        end 
                
        return readSettings
    end
    
    def getSystemPrefsProfileInformation
        details = OpenDirectory::get_directory_user_group_details_for_record_name(ServerPreferencesGroupName)
        
        if details.nil?
            Rails.logger.warn("Couldn't find user group named #{ServerPreferencesGroupName}")
            return { :profile => nil, :guid => nil, :name => nil }
        end
        
        serverPrefsGroupGUID = details['guid']
        fullName = details['full_name']
        
        systemPrefsProfile = Profile.find(:first, :conditions => {:name => fullName, :deleted => false})
        return { :profile => systemPrefsProfile, :guid => serverPrefsGroupGUID, :name => fullName }
    end
    
    def getSystemPrefsProfile
        details = OpenDirectory::get_directory_user_group_details_for_record_name(ServerPreferencesGroupName)
        
        if details.nil?
            Rails.logger.warn("Couldn't find user group named #{ServerPreferencesGroupName}")
            return nil
        end
        
        serverPrefsGroupGUID = details['guid']
        fullName = details['full_name']
        
        systemPrefsProfile = Profile.find_by_name(fullName)
        return systemPrefsProfile
    end

    def devices(payload)
        guid = payload["forUser"]
        user = User.find_by_guid(guid)
        if user.nil?
          raise "Didn't find user with guid #{guid}"
        end
        
        device_array = []
        for device in user.devices
            if ((device.last_checkin_time == nil && (device.DeviceName != nil || device.Serial != nil || device.IMEI != nil)) || (device.udid != nil && device.token != nil && device.ProductName != nil)) && device.deleted != true
              device_array.push({ :name => device.DeviceName, :udid => device.udid, :OSVersion => device.OSVersion, :ModelName => device.ModelName, :last_checkin_time => device.last_checkin_time.to_s })
            elsif device.deleted != true && (device.last_checkin_time == nil || device.last_checkin_time < ( Time.now - 60 * 60 * 24 ))
              device.delete
            end
        end

        return { :devices => device_array }
    end

    def wipeDevice(payload)
        device = Device.find_by_udid(payload)
        if device.nil? then raise "Didn't find device to wipe with udid #{payload}" end
        Task.start_task(device, "EraseDevice")
        { :result => "ok" }
    end
    
    def lockDevice(payload)
        device = Device.find_by_udid(payload)
        if device.nil? then raise "Didn't find device to lock with udid #{payload}" end
        Task.start_task(device, "DeviceLock")
        { :result => "ok" }                
    end
    
    def emailProfileToUsers(payload)
        guids = payload["guids"]
        emails = payload["emails"]
        
        profile = self.getSystemPrefsProfile
        cur_settings = Settings.get_settings
        
        if profile == nil || cur_settings.email_delivery_method == nil || cur_settings.email_server_address == nil
            return { :result => "fail" }
        else
	    if emails != nil
                for email_address in emails
                    Emailer.deliver_email_profile(email_address, profile.id)
                end
            end
            
            if guids != nil
                for guid in guids
                    user_details = OpenDirectory::get_directory_user_details_for_guid(guid)
                    email_address = user_details["email"]
                    Emailer.deliver_email_profile(email_address, profile.id)
                end
            end

            return { :result => "ok" }
        end
    end
    
    def setMdmAccessRights(payload)
        request = {"mdm_acl" => payload}
        SettingsHelper.set_mdm_acl(request)
        return { :result => "ok" }
    end
    
    def setEmailAccountSettings(payload)
        SettingsHelper.set_email_account(payload)
        return { :result => "ok" }
    end
    
    def setODMaster(payload)
        request = {"od_master" => payload["master"]}
        SettingsHelper.set_od_master(request)
        return { :result => "ok" }
    end
    
    def activateOD
        SettingsHelper.activate_od
        return { :result => "ok" }
    end
    
    def activateAPNS
        SettingsHelper.activate_apns
        return { :result => "ok" }
    end
    
    def setSSLState(payload)
        request = {"ssl_state" => payload["state"]}
        SettingsHelper.set_ssl_state(request)
        return { :result => "ok" }
    end
end

begin
    ServermgrDevicemgr::run
rescue => details
    Rails.logger.error "Exception caught #{details}:\n" + details.backtrace.join("\n")
    exit(10)
end

exit(0)
