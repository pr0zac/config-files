class DeviceController < CrudController
    before_filter :verify_device_auth_token
    before_filter :verify_device_not_timed_out
    skip_before_filter :verify_auth_token, :verify_admin_logged_in, :except => [:initialize, :find_all, :find_matching, :set_user]
    skip_before_filter :verify_device_auth_token, :except => [:start_ota, :ota_bootstrap]
    skip_before_filter :verify_post, :only => [:start_ota, :get_icon_for]
    skip_before_filter :verify_not_timed_out, :except => [:initialize, :find_all, :find_matching, :set_user]
    skip_before_filter :verify_device_not_timed_out, :except => [:start_ota, :ota_bootstrap, :get_icon_for]
    before_filter :verify_od_apns
    before_filter :verify_user_access, :only => [:start_ota, :ota_bootstrap, :get_icon_for]
    before_filter :verify_admin_logged_in, :only => [:find_all, :find_matching, :set_user]

    def initialize
        super
        @@model = Device
    end
    
    def find_all
        result = DeviceHelper.find_all
        render :json => { :result => result }
    end

    def find_matching
        post_data = request.body.read
        incoming_request = JSON.parse(post_data)
        result = DeviceHelper.find_matching(incoming_request)
        render :json => { :result => result }
    end

    def set_user
        post_data = request.body.read
        incoming_request = JSON.parse(post_data)
        result = DeviceHelper.set_user(params[:id], incoming_request)
        render :json => { :result => result }
    end

    def remove_users_device
      device = Device.find_by_id(params[:id])
      user_guid = session[:user]['generated_uid']
      user = User.find_by_guid(user_guid)
      if user != nil && device != nil && (device.user == user || session[:user]['isAdmin'])
        result = DeviceHelper.destroy(device.id)
        # Note, we wont return json, we'll just redirect back to the portal here
        return redirect_to_full_url("/profiles/", 302)
      else 
        render :text => "401 Unauthorized", :status => 401
      end
    end

    def get_icon_for
      device_type = params[:id]
      encoded_icon = IconManager.get_icon_for(device_type)
      bin_icon = Base64.decode64(encoded_icon)
      response.headers['Content-Type'] = 'image/png'
      render :text => bin_icon
    end

    def connect
        post_data = request.body.read
        incoming_request = Plist::parse_xml(post_data)
        device = Device.find_by_udid(incoming_request['UDID'])
        if device == nil
            render :text => "", :status => 403
        end        
        device.last_checkin_time = Time.now
        device.save

        return_plist = TaskHelper.handle_connect(incoming_request)
        if return_plist != nil
            render :text => return_plist
        else
            render :text => "", :status => 200
        end
    end
    
    def checkin
        post_data = request.body.read
        incoming_request = Plist::parse_xml(post_data)
        client_cert = request.env['SSL_CLIENT_CERT']
        device = Device.find_by_udid(incoming_request['UDID'])
        if device == nil
            render :text => "", :status => 403
        end
        device.last_checkin_time = Time.now
        device.save
    
        if incoming_request['MessageType'] == 'TokenUpdate'
            device.token = Base64.encode64(incoming_request['Token'].read())
            device.push_magic = incoming_request['PushMagic']
            if incoming_request.key?('UnlockToken')
                device.unlock_token = Base64.encode64(incoming_request['UnlockToken'].read())
            end
            device.save
            Task.start_new(device, "UpdateInformation")
            Task.start_new(device, "PushSettings")
            render :text => "", :status => 200
        elsif incoming_request['MessageType'] == 'Authenticate'
            render :text => "", :status => 200
        else
            render :text => "400 Bad Request", :status => 400
        end
    end
    
    def ota_bootstrap
        device_identifier = params['device_identifier']
        device_type = params['device_type']

        user_guid = session[:user]['generated_uid']
        if user_guid != nil
            user = User.find_by_guid(user_guid)
            if user == nil
                user = User.new
                user.guid = user_guid
                user.save
            end
            device = Device.new
            uuid = UUID.new
            device.reg_challenge = uuid.generate
            device.user = user
            device.last_checkin_time = Time.now
            device.identifier = device_identifier
            device.device_type = device_type
            device.save
            bootstrap_profile = ProfileManager.generate_ota_bootstrap_profile(device.reg_challenge, request.host)
            response.headers['Content-Type'] = 'application/x-apple-aspen-config'
            response.headers['Content-Disposition'] = "attachment; filename=ota_profile.mobileconfig"
            render :xml => bootstrap_profile
        else
            render :text => "401 Unauthorized", :status => 401
        end
    end
        
    def ota_service
        uuid = UUID.new
        post_data = request.body.read
        signed_response = OpenSSL::PKCS7.new(post_data)
        store = OpenSSL::X509::Store.new
        signed_response.verify(nil, store, nil, OpenSSL::PKCS7::NOVERIFY)
        incoming_request = Plist::parse_xml(signed_response.data)
        
        if incoming_request.key?("CHALLENGE")
            device = Device.find_by_reg_challenge(incoming_request["CHALLENGE"])
            
            if device == nil
                render :text => "401 Unauthorized", :status => 401
            end

            old_device = Device.find_by_udid(incoming_request["UDID"])
            if old_device == nil && incoming_request.has_key?("SERIAL")
              old_device = Device.find_by_Serial(incoming_request["SERIAL"])
            end
            if old_device == nil && incoming_request.has_key?("IMEI")
              old_device = Device.find_by_IMEI(incoming_request["IMEI"])
            end
            if old_device != nil && device != old_device
                old_device.deleted = false
                old_device.user = device.user
                old_device.reg_challenge = device.reg_challenge
                old_device.ProfileList = []
                old_device.ProvisioningProfileList = []
                old_device.save
                device.destroy
                device = old_device
            end

            device.udid = incoming_request["UDID"]
            device.Serial = incoming_request["SERIAL"]
            device.IMEI = incoming_request["IMEI"]
            device.OSVersion = incoming_request["OSVERSION"]
            device.Product = incoming_request["PRODUCT"]
            device.last_checkin_time = Time.now
            device.save
            
            for provisioning_profile in ProvisioningProfile.all
                if provisioning_profile.ProvisionedDevices.include?(device.udid)
                    provisioning_profile.devices.push(device)
                    provisioning_profile.save
                end
            end
            
            incoming_request.delete("CHALLENGE")
            incoming_request.delete("UDID")
            for attribute in incoming_request.keys
                device[attribute] = incoming_request[attribute]
            end

            device.reg_cert = ProfileManager::encoded_identity_cert
            device.reg_cert_uuid = UUID.new.generate
            device.last_checkin_time = Time.now
            device.save
            cert_profile = ProfileManager::generate_ota_cert_profile(device.reg_cert, device.reg_cert_uuid)
            render :text => cert_profile

            # binding_profile = ProfileManager::generate_scep_profile(device, request.host)
            # render :text => binding_profile
        elsif incoming_request.key?("UDID")
            device = Device.find_by_udid(incoming_request["UDID"])
            
            if device == nil
                render :text => "401 Unauthorized", :status => 401
            end
            
            device.last_checkin_time = Time.now
            device.reg_challenge = nil
            device.save
            
            binding_profile = ProfileManager::generate_mdm_binding_profile(device, request.host)
            render :text => binding_profile
        else
           render :text => "401 Unauthorized", :status => 401
        end
    end
    
    def start_ota
        @cur_settings = Settings.get_settings.attributes
        user_guid = session[:user]['generated_uid']
        user = User.find_by_guid(user_guid)
        @user_is_admin = OpenDirectory::is_user_an_admin(user_guid) || false
        @devices = []
        @profile_data = []
        
        if user != nil
            profiles = user.get_adhoc_profiles | Profile.find(:all, :conditions => {:is_from_servermgr => true})
            @devices = (user.devices || []).sort { |a,b| -(a.created_at <=> b.created_at) }
            for profile in profiles
                profile_hash = { :name => profile.name,
                                 :description => profile.general_knob_sets.first.description,
                                 :id => profile.id
                               }
            
                knob_set_array = []
                for knob_set in profile.knob_sets
                    if knob_set.class.payload_subidentifier
                        knob_set_array.push(knob_set.class.payload_subidentifier)
                    end
                end
            
                knob_set_array.uniq!

                profile_hash[:knob_set_types] = knob_set_array
            
                @profile_data.push(profile_hash)
            end
        end
    end
end
