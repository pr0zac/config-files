class Offer < ActiveRecord::Base
  include BCrypt
  belongs_to :created_user, :class_name => "User"
  has_many :transfers
  has_and_belongs_to_many(:allowed_users,
  :class_name => "User",
  :join_table => "allowed_users_offers",
  :foreign_key => "offer_id",
  :association_foreign_key => "allowed_user_id")
  
  serialize :pw_failures, Array
  
  validates_uniqueness_of :offer_key, :case_sensitive => false
  
  def self.create_with_info(offer_info)
    Offer.delay.create_spare_offers
    offer = Offer.find(:first, :conditions => {:used => false}, :lock => true)
    if offer
      offer.used = true
      offer.save
    else
      offer = Offer.new
      offer.used = true
      alphanumerics = [('0'..'9'),('a'..'z')].map {|range| range.to_a}.flatten
      
      begin
        offer.offer_key = (0...5).map { alphanumerics[Kernel.rand(alphanumerics.size)] }.join
      end while not offer.save
    end
    offer.peer_id = offer_info[:peer_id]
    offer.persistent = offer_info[:persistent]
    offer.total_size = offer_info[:total_size]
    offer.file_count = offer_info[:file_count]
    offer.created_user_id = offer_info[:created_user_id]
    if offer_info[:created_by_app]
      offer.created_by_app = offer_info[:created_by_app]
    else
      offer.created_by_app = false
    end
    offer.created_ip = offer_info[:created_ip]
    offer.last_keep_alive = Time.now
    offer.passworded = offer_info[:passworded]
    if offer.passworded
      offer.password = offer_info[:password]
    end
    offer.pw_failures = []
    if offer.save
      if offer_info[:allowed_users] and offer_info[:allowed_users].count > 0
        for id in offer_info[:allowed_users]
          user = User.find_by_id(id)
          if user
            offer.allowed_users.push(user)
          end
        end
      end
      offer.save
      return offer
    else
      return nil
    end
  end
  
  def self.find_by_offer_key_cached(offer_key)
    # Rails.cache.fetch("offer#{offer_key}", :expires_in => 1.hours) do
      Offer.find_by_offer_key(offer_key)
    # end
  end
  
  def self.create_spare_offers
    alphanumerics = [('0'..'9'),('a'..'z')].map {|range| range.to_a}.flatten
    
    while Offer.find(:all, :conditions => {:used => false}).count < 100
      offer = Offer.new
      offer.used = false
      begin
        offer.offer_key = (0...5).map { alphanumerics[Kernel.rand(alphanumerics.size)] }.join
      end while not offer.save
    end
  end
  
  def save_with_cache
    if self.save
      # Rails.cache.write("offer#{self.offer_key}", self, :expires_in => 1.hours)
      return true
    else
      # Rails.cache.delete("offer#{self.offer_key}")
      return false
    end
  end
  
  def password
    @password ||= Password.new(password_hash)
  end

  def password=(new_password)
    @password = Password.create(new_password)
    self.password_hash = @password
  end
  
  def claim_count
    return self.transfers.length
  end
  
  def active
    return (self.persistent || self.claim_count == 0) && self.last_keep_alive > Time.now-120
  end
  
  def get_attributes
    attrs = self.attributes.symbolize_keys
    attrs.delete(:password_hash)
    attrs[:claim_count] = self.transfers.length
    attrs[:transfers] = self.transfers.map { |transfer| transfer.id }
    attrs[:allowed_users] = self.allowed_users.map { |allowed_user| allowed_user.id }
    return attrs
  end
end
